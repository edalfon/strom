---
title: "Correlations"
execute:
  echo: false
---

```{python}
#| include: false
%load_ext sql
%sql duckdb:///./duckdb/strom.duckdb

import epyfun
import pandas as pd
```

```{python}
#| include: false
%%sql

SELECT *
FROM waermestrom_minute
;
```


```{python}
#| include: false
%%sql

waermestrom_per_day << SELECT 
  minute::DATE AS date,
  24.0 * 60.0 * AVG(cm) AS wd,
  SUM(CASE WHEN value IS NOT NULL THEN 1 ELSE 0 END) AS wobs,
FROM waermestrom_minute
WHERE minute <= '2021-05-25' OR minute >= '2022-11-30'
GROUP BY minute::DATE
;
```


```{python}
#| include: false
%%sql

normalstrom_per_day << SELECT 
  minute::DATE AS date,
  24.0 * 60.0 * AVG(cm) AS nd,
  SUM(CASE WHEN value IS NOT NULL THEN 1 ELSE 0 END) AS nobs,
FROM strom_minute
WHERE minute <= '2021-05-25' OR minute >= '2022-11-30'
GROUP BY minute::DATE
;
```

```{python}
strom_per_day = pd.merge(
    normalstrom_per_day, waermestrom_per_day, on="date", validate="one_to_one"
)
```


```{python}
#| eval: false
import sweetviz as sw
report = sw.analyze(strom_per_day)
report.show_html("output.html", open_browser=True)
```

A few rows have different number of obs. How can this be?
```{python}
discrepancies = strom_per_day[strom_per_day['nobs'] != strom_per_day['wobs']]
discrepancies_dates = "', '".join(discrepancies["date"].astype(str).to_list())
print(discrepancies_dates)
discrepancies
```



```{python}
%%sql

SELECT * FROM waermestrom_minute 
WHERE minute::DATE IN ('{{discrepancies_dates}}')
AND value IS NOT NULL
;
```


```{python}
%%sql

SELECT * FROM strom_minute 
WHERE minute::DATE IN ('{{discrepancies_dates}}')
AND value IS NOT NULL
;
```


Ok, there are a couple of cases explained by measurement at midnight, and waermestrom was measured before midnight and normal storm after midnight, so it counts at the next day. Other case seems to simply be that I did not measure normal strom (presumably, because there was not measurable consumption, due to short period)

so let's just keep one of those and move on

```{python}
strom_per_day = strom_per_day.drop(columns="nobs").rename(columns={"wobs":"obs"})
strom_per_day
```


```{python}
import pandas as pd
climate_daily = pd.read_parquet("./interim/climate/climate_daily.parquet")
climate_daily = epyfun.pandas.clean_names(climate_daily)
```

```{python}
strom_climate = pd.merge(strom_per_day, climate_daily, on='date', how='left')
strom_climate = strom_climate[strom_climate.notna().all(axis=1)]
strom_climate
```

```{python}
strom_climate.to_parquet("interim/strom_climate.parquet")
```

```{python}
#| eval: false
import sweetviz as sw
report = sw.analyze(strom_climate)
report.show_html("output.html", open_browser=True)

#Pandas-Profiling
#Sweetviz
#Autoviz
#D-Tale
#DataPrep
#FastEDA  https://medium.com/bitgrit-data-science-publication/fast-exploratory-data-analysis-with-one-line-of-code-677fcba2342e
```


```{python}
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Assuming df is your DataFrame with the selected columns
# Replace these column names with the ones you want to include in the correlation matrix
selected_columns = [
    "nd",
    "wd",
    "obs",
    "tt_tu_min",
    "tt_tu_mean",
    "tt_tu_max",
    "rf_tu_min",
    "rf_tu_mean",
    "rf_tu_max",
]

# Create a DataFrame with the selected columns
selected_df = strom_climate[selected_columns]

# Calculate the correlation matrix
correlation_matrix = selected_df.corr()

# Plot the correlation matrix as a heatmap
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f", linewidths=.5)
plt.title('Correlation Matrix Plot')
plt.show()

```


```{python}
import pandas as pd
import matplotlib.pyplot as plt
from pandas.plotting import scatter_matrix

# Create a DataFrame with the selected columns
selected_df = strom_climate[selected_columns]

# Plot the scatter plot matrix
scatter_matrix(selected_df, alpha=0.8, figsize=(10, 8), diagonal='hist')
plt.suptitle('Scatter Plot Matrix', y=1.02)
plt.show()

```



```{python}
# https://plotly.com/python/splom/
# https://plotly.com/python/reference/splom/
# https://plotly.com/python-api-reference/generated/plotly.express.scatter_matrix
# https://community.plotly.com/t/how-can-i-change-the-color-of-selected-points-in-scatterplots/32013/3

import pandas as pd
import plotly.express as px

# Create a DataFrame with the selected columns
selected_df = strom_climate[selected_columns]

# Create a scatter plot matrix using Plotly
fig = px.scatter_matrix(selected_df, dimensions=selected_columns, opacity=0.3)

fig.update_traces(
    selected_marker_color="red",
    selected_marker_opacity=0.7,
    selector=dict(type="splom"),
)
fig.update_layout(autosize=True)  # remove height=800
fig.update_traces(diagonal=dict(visible=False), selector=dict(type="splom"))
fig.update_traces(showupperhalf=False, selector=dict(type="splom"))
# Update layout for better visualization
# fig.update_layout(
#     height=800,
#     width=800,
# )

# Show the plot
fig.show()
```

```{python}
#| eval: false
fig.update_layout(autosize=True) # remove height=800
fig.show(renderer="browser")  # remove display(fig)
```



some first-look insights

- it's good that the correlation between normal and warme strom consumption is very low. It is expected, and could be useful to use normal strom utilization as a proxy for other things (i.e. being at home basically)
- also as expected, the correlation between normal strom utilization and temprature is low.
- there is a nice and strong negative correlation between temperature and wärmestrom consumption. It is not strictly linear though. Rather polinomial (inverse) relatioship.
- there seems to be some sort of weak positive correlation between wärmestrom and relative humidity. Not at all consistent though. It is positive with min and mean humidity, but negative or non-existent with max humidity. It may well be just an artifact or spurious correlation, explained by temperature, because there is indeed a correlation (not that strong, though) between temperature and humidity.
- the number of observations are somewhat related to the temperature, which kinda makes sense, because the measurements are not random. I am much more likely to measure the thing when it's cold!, and that seems to be reflected in the data.

